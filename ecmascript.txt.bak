原始类型:
undefined
boolean
string
number
object的引用(null或者引用)。
原始类型占据的空间是固定的，存放在栈中，
在许多语言中，字符串都被看作引用类型，而非原始类型，因为字符串的长度是可变的。ECMAScript打破了这一传统。

对变量或值调用typeof运算符将返回下列值之一：
undefined
boolean
string
number
object

//
var oTemp;
alert(oTemp == undefined);  //输出 true

var oTemp;
alert(typeof oTemp); //输出 "undefined"



特殊的number 
infinity
NaN
isFinite()
isNaN(); 字符无法转换为数值

引用类型（class）

在使用typeof运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回"object"。
ECMAScript引入了另一个Java运算符instanceof来解决这个问题。

把对象的所有引用都设置为 null，可以强制性地废除对象

类的定义：
联合使用构造函数和原型方式
即用构造函数定义对象的所有非函数属性，用原型方式定义对象的函数属性（方法）。
结果是，所有函数都只创建一次，而每个对象都具有自己的对象属性实例。

创建类的最好方式是用构造函数定义属性，用原型定义方法。

function Car(sColor,iDoors,iMpg) {
  this.color = sColor;
  this.doors = iDoors;
  this.mpg = iMpg;
  this.drivers = new Array("Mike","John");
}

Car.prototype.showColor = function() {
  alert(this.color);
};

var oCar1 = new Car("red",4,23);

不要这样加：
var str = "hello ";
str += "world";

这样加：
var arr = new Array();
arr[0] = "hello ";
arr[1] = "world";
var str = arr.join("");

避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句
// 函数声明语句
{
  let a = 'secret';
  function f() {
    return a;
  }
}

// 函数表达式
{
  let a = 'secret';
  let f = function () {
    return a;
  };
}

对于const来说，只声明不赋值，就会报错

数组的解构：
let [head,middle, ...tail] = [1, 2, 3, 4];
head // 1
middle //2
tail // [3, 4]

对象的解构
let obj = { first: 'hello', last: 'world' };
let { first: f, last: l } = obj;

由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。
var arr = [1, 2, 3];
var {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3

只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值
set map

如果要将一个已经声明的变量用于解构赋值，必须非常小心。
// 错误的写法
var x;
{x} = {x: 1};
// SyntaxError: syntax error

// 正确的写法
({x} = {x: 1});



// ES6的写法
Number.parseInt('12.34') // 12
Number.parseFloat('123.45#') // 123.45

 
//把对象转化为数组   Array.from(object_)
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};
// ES6的写法
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合

值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组
// NodeList对象
[...document.querySelectorAll('div')]

//对象的合并
Object.assign()  
//可以用来克隆对象
function clone(origin) {
  return Object.assign({}, origin);
}

var obj = { foo: "bar", baz: 42 };
Object.keys(obj)
// ["foo", "baz"]


rest参数：（让逗号变成数组）

扩展运算符：（让数组变成逗号）

function push(array, ...items) {  //rest参数
  array.push(...items);   //扩展运算符
}

push(myArr,1,2,3)

箭头函数：
var sum = (num1, num2) => num1 + num2;
var sum = (num1, num2) => { return num1 + num2; }
// 等同于
var sum = function(num1, num2) {
  return num1 + num2;
};

SET成员的值都是唯一的，没有重复的值

Array.from方法可以将Set结构转为数组。
var items = new Set([1, 2, 3, 4, 5]);
var array = Array.from(items);

数组去重
Arr = [...new Set(Arr)];

数组.splice(操作起始点,删除数量,替换的元素内容...)



ES6模块的import和export用法总结
ES6之前已经出现了js模块加载的方案，最主要的是CommonJS和AMD规范。


/********************************************************************/
Object.entries方法的另一个用处是，将对象转为真正的Map结构。

const obj = { foo: 'bar', baz: 42 };
const map = new Map(Object.entries(obj));







/********************************************************************/